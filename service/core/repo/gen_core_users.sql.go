// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.14.0
// source: gen_core_users.sql

package core_repo

import (
	"context"
)

const addCoreUser = `-- name: AddCoreUser :one

INSERT INTO "public"."core_users" (email,username,password,fullname) VALUES ($1, $2, $3, $4) RETURNING uid, email, username, password, fullname, is_public, is_verified, is_blocked, updated_at, created_at
`

type AddCoreUserParams struct {
	Email    string `json:"email"`
	Username string `json:"username"`
	Password string `json:"password"`
	Fullname string `json:"fullname"`
}

// ------------------------------ ADD ONE CORE_USERS <-> CORE_USER  ------------------------------
func (q *Queries) AddCoreUser(ctx context.Context, arg AddCoreUserParams) (CoreUser, error) {
	row := q.db.QueryRowContext(ctx, addCoreUser,
		arg.Email,
		arg.Username,
		arg.Password,
		arg.Fullname,
	)
	var i CoreUser
	err := row.Scan(
		&i.Uid,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.Fullname,
		&i.IsPublic,
		&i.IsVerified,
		&i.IsBlocked,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getCoreUserWithEmail = `-- name: GetCoreUserWithEmail :one
SELECT uid, email, username, password, fullname, is_public, is_verified, is_blocked, updated_at, created_at FROM "public"."core_users" WHERE email = $1 LIMIT 1
`

func (q *Queries) GetCoreUserWithEmail(ctx context.Context, email string) (CoreUser, error) {
	row := q.db.QueryRowContext(ctx, getCoreUserWithEmail, email)
	var i CoreUser
	err := row.Scan(
		&i.Uid,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.Fullname,
		&i.IsPublic,
		&i.IsVerified,
		&i.IsBlocked,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getCoreUserWithUid = `-- name: GetCoreUserWithUid :one

SELECT uid, email, username, password, fullname, is_public, is_verified, is_blocked, updated_at, created_at FROM "public"."core_users" WHERE uid = $1 LIMIT 1
`

// ------------------------------ GET ONE CORE_USERS <== CORE_USER  ------------------------------
func (q *Queries) GetCoreUserWithUid(ctx context.Context, uid int64) (CoreUser, error) {
	row := q.db.QueryRowContext(ctx, getCoreUserWithUid, uid)
	var i CoreUser
	err := row.Scan(
		&i.Uid,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.Fullname,
		&i.IsPublic,
		&i.IsVerified,
		&i.IsBlocked,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getCoreUserWithUsername = `-- name: GetCoreUserWithUsername :one
SELECT uid, email, username, password, fullname, is_public, is_verified, is_blocked, updated_at, created_at FROM "public"."core_users" WHERE username = $1 LIMIT 1
`

func (q *Queries) GetCoreUserWithUsername(ctx context.Context, username string) (CoreUser, error) {
	row := q.db.QueryRowContext(ctx, getCoreUserWithUsername, username)
	var i CoreUser
	err := row.Scan(
		&i.Uid,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.Fullname,
		&i.IsPublic,
		&i.IsVerified,
		&i.IsBlocked,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const listCoreUsers = `-- name: ListCoreUsers :many

SELECT uid, email, username, password, fullname, is_public, is_verified, is_blocked, updated_at, created_at FROM "public"."core_users"
`

// ------------------------------ GET MULTIPLE CORE_USERS <== [CORE_USERS] ------------------------------
func (q *Queries) ListCoreUsers(ctx context.Context) ([]CoreUser, error) {
	rows, err := q.db.QueryContext(ctx, listCoreUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CoreUser{}
	for rows.Next() {
		var i CoreUser
		if err := rows.Scan(
			&i.Uid,
			&i.Email,
			&i.Username,
			&i.Password,
			&i.Fullname,
			&i.IsPublic,
			&i.IsVerified,
			&i.IsBlocked,
			&i.UpdatedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCoreUsersWithLimit = `-- name: ListCoreUsersWithLimit :many
SELECT uid, email, username, password, fullname, is_public, is_verified, is_blocked, updated_at, created_at FROM "public"."core_users" LIMIT $1::int
`

func (q *Queries) ListCoreUsersWithLimit(ctx context.Context, limit int32) ([]CoreUser, error) {
	rows, err := q.db.QueryContext(ctx, listCoreUsersWithLimit, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CoreUser{}
	for rows.Next() {
		var i CoreUser
		if err := rows.Scan(
			&i.Uid,
			&i.Email,
			&i.Username,
			&i.Password,
			&i.Fullname,
			&i.IsPublic,
			&i.IsVerified,
			&i.IsBlocked,
			&i.UpdatedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCoreUsersWithLimitOffset = `-- name: ListCoreUsersWithLimitOffset :many
SELECT uid, email, username, password, fullname, is_public, is_verified, is_blocked, updated_at, created_at FROM "public"."core_users" LIMIT $2::int OFFSET $1::int
`

type ListCoreUsersWithLimitOffsetParams struct {
	Offset int32 `json:"offset_"`
	Limit  int32 `json:"limit_"`
}

func (q *Queries) ListCoreUsersWithLimitOffset(ctx context.Context, arg ListCoreUsersWithLimitOffsetParams) ([]CoreUser, error) {
	rows, err := q.db.QueryContext(ctx, listCoreUsersWithLimitOffset, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CoreUser{}
	for rows.Next() {
		var i CoreUser
		if err := rows.Scan(
			&i.Uid,
			&i.Email,
			&i.Username,
			&i.Password,
			&i.Fullname,
			&i.IsPublic,
			&i.IsVerified,
			&i.IsBlocked,
			&i.UpdatedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeCoreUserWithEmail = `-- name: RemoveCoreUserWithEmail :exec
DELETE FROM "public"."core_users" WHERE email = $1
`

func (q *Queries) RemoveCoreUserWithEmail(ctx context.Context, email string) error {
	_, err := q.db.ExecContext(ctx, removeCoreUserWithEmail, email)
	return err
}

const removeCoreUserWithUid = `-- name: RemoveCoreUserWithUid :exec

DELETE FROM "public"."core_users" WHERE uid = $1
`

// ------------------------------ REMOVE ONE CORE_USERS -> nil  ------------------------------
func (q *Queries) RemoveCoreUserWithUid(ctx context.Context, uid int64) error {
	_, err := q.db.ExecContext(ctx, removeCoreUserWithUid, uid)
	return err
}

const removeCoreUserWithUsername = `-- name: RemoveCoreUserWithUsername :exec
DELETE FROM "public"."core_users" WHERE username = $1
`

func (q *Queries) RemoveCoreUserWithUsername(ctx context.Context, username string) error {
	_, err := q.db.ExecContext(ctx, removeCoreUserWithUsername, username)
	return err
}

const updateCoreUserBlocked = `-- name: UpdateCoreUserBlocked :one
UPDATE "public"."core_users" SET is_blocked = $1 WHERE uid = $2 RETURNING uid, email, username, password, fullname, is_public, is_verified, is_blocked, updated_at, created_at
`

type UpdateCoreUserBlockedParams struct {
	IsBlocked bool  `json:"is_blocked"`
	Uid       int64 `json:"uid"`
}

func (q *Queries) UpdateCoreUserBlocked(ctx context.Context, arg UpdateCoreUserBlockedParams) (CoreUser, error) {
	row := q.db.QueryRowContext(ctx, updateCoreUserBlocked, arg.IsBlocked, arg.Uid)
	var i CoreUser
	err := row.Scan(
		&i.Uid,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.Fullname,
		&i.IsPublic,
		&i.IsVerified,
		&i.IsBlocked,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const updateCoreUserName = `-- name: UpdateCoreUserName :one

UPDATE "public"."core_users" SET fullname = $1 WHERE uid = $2 RETURNING uid, email, username, password, fullname, is_public, is_verified, is_blocked, updated_at, created_at
`

type UpdateCoreUserNameParams struct {
	Fullname string `json:"fullname"`
	Uid      int64  `json:"uid"`
}

// ------------------------------ UPDATE ONE CORE_USERS <-> CORE_USERS  ------------------------------
func (q *Queries) UpdateCoreUserName(ctx context.Context, arg UpdateCoreUserNameParams) (CoreUser, error) {
	row := q.db.QueryRowContext(ctx, updateCoreUserName, arg.Fullname, arg.Uid)
	var i CoreUser
	err := row.Scan(
		&i.Uid,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.Fullname,
		&i.IsPublic,
		&i.IsVerified,
		&i.IsBlocked,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const updateCoreUserPassword = `-- name: UpdateCoreUserPassword :one
UPDATE "public"."core_users" SET password = $1 WHERE uid = $2 RETURNING uid, email, username, password, fullname, is_public, is_verified, is_blocked, updated_at, created_at
`

type UpdateCoreUserPasswordParams struct {
	Password string `json:"password"`
	Uid      int64  `json:"uid"`
}

func (q *Queries) UpdateCoreUserPassword(ctx context.Context, arg UpdateCoreUserPasswordParams) (CoreUser, error) {
	row := q.db.QueryRowContext(ctx, updateCoreUserPassword, arg.Password, arg.Uid)
	var i CoreUser
	err := row.Scan(
		&i.Uid,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.Fullname,
		&i.IsPublic,
		&i.IsVerified,
		&i.IsBlocked,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const updateCoreUserPublic = `-- name: UpdateCoreUserPublic :one
UPDATE "public"."core_users" SET is_public = $1 WHERE uid = $2 RETURNING uid, email, username, password, fullname, is_public, is_verified, is_blocked, updated_at, created_at
`

type UpdateCoreUserPublicParams struct {
	IsPublic bool  `json:"is_public"`
	Uid      int64 `json:"uid"`
}

func (q *Queries) UpdateCoreUserPublic(ctx context.Context, arg UpdateCoreUserPublicParams) (CoreUser, error) {
	row := q.db.QueryRowContext(ctx, updateCoreUserPublic, arg.IsPublic, arg.Uid)
	var i CoreUser
	err := row.Scan(
		&i.Uid,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.Fullname,
		&i.IsPublic,
		&i.IsVerified,
		&i.IsBlocked,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const updateCoreUserUsername = `-- name: UpdateCoreUserUsername :one
UPDATE "public"."core_users" SET username = $1 WHERE uid = $2 RETURNING uid, email, username, password, fullname, is_public, is_verified, is_blocked, updated_at, created_at
`

type UpdateCoreUserUsernameParams struct {
	Username string `json:"username"`
	Uid      int64  `json:"uid"`
}

func (q *Queries) UpdateCoreUserUsername(ctx context.Context, arg UpdateCoreUserUsernameParams) (CoreUser, error) {
	row := q.db.QueryRowContext(ctx, updateCoreUserUsername, arg.Username, arg.Uid)
	var i CoreUser
	err := row.Scan(
		&i.Uid,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.Fullname,
		&i.IsPublic,
		&i.IsVerified,
		&i.IsBlocked,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const updateCoreUserVerified = `-- name: UpdateCoreUserVerified :one
UPDATE "public"."core_users" SET is_verified = $1 WHERE uid = $2 RETURNING uid, email, username, password, fullname, is_public, is_verified, is_blocked, updated_at, created_at
`

type UpdateCoreUserVerifiedParams struct {
	IsVerified bool  `json:"is_verified"`
	Uid        int64 `json:"uid"`
}

func (q *Queries) UpdateCoreUserVerified(ctx context.Context, arg UpdateCoreUserVerifiedParams) (CoreUser, error) {
	row := q.db.QueryRowContext(ctx, updateCoreUserVerified, arg.IsVerified, arg.Uid)
	var i CoreUser
	err := row.Scan(
		&i.Uid,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.Fullname,
		&i.IsPublic,
		&i.IsVerified,
		&i.IsBlocked,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}
